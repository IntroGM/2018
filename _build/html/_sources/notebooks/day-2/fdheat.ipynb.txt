{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Finite differences for heat equation"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Simple 1D diffusion-only constant-conductivity heat equation is $$\\rho C_p \\frac{\\partial T}{\\partial t} = k \\frac{\\partial^2 T}{\\partial x^2}$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The second-order spatial derivative of temperature can be approximated with finite differences: \n",
    "$$\\frac{\\partial^2 T}{\\partial x^2}\\Big\\vert_{x=x_1}^{t=t_1} \n",
    "\\approx \\left(\\frac{\\partial T}{\\partial x}\\Big\\vert_{x=x_1+0.5\\Delta x}^{t=t_1} - \\frac{\\partial T}{\\partial x}\\Big\\vert_{x=x_1-0.5\\Delta x}^{t=t_1}\\right) / \\Delta x \n",
    "\\approx \\left(\\frac{T_{x=x_1+\\Delta x}^{t=t_1} - T_{x=x_1}^{t=t_1}}{\\Delta x} - \\frac{T_{x=x_1}^{t=t_1} - T_{x=x_1-\\Delta x}^{t=t_1}}{\\Delta x}\\right) / \\Delta x\n",
    "= \\frac{T_{x=x_1+\\Delta x}^{t=t_1} - 2T_{x=x_1}^{t=t_1} + T_{x=x_1 - \\Delta x}^{t=t_1}}{(\\Delta x)^2}$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Since $x_1 - \\Delta x = x_0$ and $x_1 + \\Delta x = x_2$, we get\n",
    "$$\\frac{\\partial^2 T}{\\partial x^2}\\Big\\vert_{x=x_1}^{t=t_1} \\approx \\frac{T_{x=x_2}^{t=t_1} - 2T_{x=x_1}^{t=t_1} + T_{x=x_0}^{t=t_1}}{(\\Delta x)^2} = \\frac{T_{2}^{1} - 2T_{1}^{1} + T_{0}^{1}}{(\\Delta x)^2}$$ where the last formula uses the short hand notation for indices. Note that here the superscripts do not mean \"to power\" but are indices for time steps."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Using the same short hand notation, we can approximate the time derivative of the temperature: \n",
    "$$\\frac{\\partial T}{\\partial t}\\Big\\vert_{x=x_1}^{t=t_1} \\approx \\frac{T_1^2-T_1^1}{\\Delta t}$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "These approximations can be generalized:\n",
    "\n",
    "$$\\frac{\\partial^2 T}{\\partial x^2}\\Big\\vert_{x=x_i}^{t=t_q} \\approx \\frac{T_{i+1}^{q} - 2T_{i}^{q} + T_{i-1}^{q}}{(\\Delta x)^2}$$\n",
    "\n",
    "$$\\frac{\\partial T}{\\partial t}\\Big\\vert_{x=x_i}^{t=t_q} \\approx \\frac{T_i^{q+1}-T_i^q}{\\Delta t}$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "And thus the full finite differences approximation of the heat equation can be written as\n",
    "\n",
    "$$ \\rho C_p \\frac{T_i^{q+1}-T_i^q}{\\Delta t} = k \\frac{T_{i+1}^{q} - 2T_{i}^{q} + T_{i-1}^{q}}{(\\Delta x)^2}$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This applies to *any* $q$ and $i$. If we know $T$ everywhere at time $t_q$, we can calculate $T$ at time $t_{q+1} = t_q + \\Delta t$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Do\n",
    "\n",
    "- How would the implicit (backward difference in time) approximation look like for the heat equation? Recall that in the implicit approximation we used the values from the next time step to approximate the derivative. What is the problem in calculating $T_i^q$ using the implicit approximation?\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Boundary conditions, initial conditions\n",
    "\n",
    "To start calculating the values of $T$, we need the *initial* values at some time $t_0$. This temperature field is the so called *initial condition* for our problem. It is a type of boundary condition that applies to a temporally variable field.\n",
    "\n",
    "(Spatial) boundary conditions are needed because when applying finite differences to a differential equation (in space), we need the surrounding values, such as $T_{i+1}$ and $T_{i-1}$ in the case of heat equation, to calculate the next value of $T_{i}$. These values are not available if we are near the geometrical boundary of the problem."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## FD, heat equation, and cooling of an intrusion"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Next we will use finite differences to model the cooling of a (very large) magma intrusion within the crust. The crust is limited by the upper surface and the crust-mantle boundary at the bottom. It is 35 km thick and intruded by a horizontal, granitic magma intrusion (sill) that extends from 5 km to 10 km depth. Our task is to calculate the temperature distribution in the crust after 100 kyrs.\n",
    "\n",
    "Our strategy for solving the problem in Python is following:\n",
    "\n",
    " 0. Draw a picture!\n",
    " 0. Decide on model geometry and physical parameters\n",
    "     - one-dimensional\n",
    "     - homogeneous physical parameters\n",
    "     - $\\Rightarrow$ we can use the equation above\n",
    " 1. Set physical parameters ($\\rho$, $C_p$, $k$)\n",
    " 2. Set geometrical parameters ($L$, $\\Delta x$ $\\Rightarrow$ `nx`)\n",
    " 3. Set total run time and time step size ($t_{total}$, $\\Delta t$ $\\Rightarrow$ `nt`)\n",
    " 4. Decide and set boundary condition values $T_0$ and $T_{nx-1}$\n",
    " 5. Create two arrays that hold the temperature, size `nx` elements\n",
    "     - `Tnew` for $T^{q+1}$\n",
    "     - `Tprev` for $T^{q}$\n",
    " 6. Create an array for grid point locations ($x$ coordinates), size `nx`\n",
    " 7. Set `Tprev` to hold the initial temperature field\n",
    "     - Linear geotherm throughout the crust, constant temperature within the sill\n",
    " 8. Start the loop that iterates over all the time steps. Within the time step:\n",
    "     - Set the temperature at the boundaries, according to boundary conditions, at `Tnew[0]` and `Tnew[nx-1]`\n",
    "     - Calculate remaining (internal grid points) within `Tnew` based on values of `Tprev`\n",
    "     - Prepare for next time step: Copy all values of `Tnew` to `Tprev`\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Do\n",
    "\n",
    "- Use the following frame to start implementing the code. Once the code seems to work, experiment with it:\n",
    "    - How does changing values of `Cp` and `rho` affect the results?\n",
    "    - Give `dt` values that are close to the critical time step. How do the results change?\n",
    "    - Can the code handle intrusions that are only 500 m in width?\n",
    "- What have silently assumed in the implementation of the code? E.g. can we model the problem in simplified 1D world? What kind of physical processes, that are likely to be present, have we omitted?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Frame for FD solution for heat diffusion\n",
    "# Fill in lines marked with \"(...)\"\n",
    "\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Set material properties\n",
    "rho = (...)   # rock density, kg m^-3\n",
    "Cp = (...)    # rock heat capacity, J kg^-1 K^-1\n",
    "k = (...)     # rock heat conductivity, W m^-1 K^-1\n",
    "\n",
    "# Set geometry and dimensions\n",
    "L = (...)        # thickness of the crust, m\n",
    "nx = (...)       # number of grid points, -\n",
    "dx = L / (nx-1)  \n",
    "print(\"dx is\", dx, \"m\")\n",
    "\n",
    "silltop = (...)   # depth of the top of the sill, m\n",
    "sillbott = (...)  # depth of the bottom of the sill, m\n",
    "\n",
    "# Set total time and time step\n",
    "t_total = (...)           # total run time, s\n",
    "dt = (...)                # time step, s\n",
    "nt = int(np.floor(t_total / dt))\n",
    "print(\"Calculating\", nt, \"time steps\")\n",
    "\n",
    "# Set boundary temperature values and intrusion temperature\n",
    "Tsurf = (...)      # surface temperature, deg C\n",
    "Tmoho = (...)      # Moho temperature, deg C\n",
    "Tintrusion = (...) # Intrusion temperature, deg C\n",
    "\n",
    "# TODO: Create arrays to hold temperature fields.\n",
    "# These need to have `nx` elements and can be \n",
    "# set to zero for now.\n",
    "Tnew = (...)\n",
    "Tprev = (...)\n",
    "\n",
    "# TODO: Create coordinates of the grid points.\n",
    "# We want `x` to have evenly spaced values \n",
    "# from zero to `L`, with `nx` elements.\n",
    "# Use `np.linspace()`.\n",
    "x = (...)\n",
    "\n",
    "# Generate initial temperature field.\n",
    "# \n",
    "for ix in range(nx):\n",
    "    # TODO: Add condition that tests whether \n",
    "    # element `ix` of `x` is inside the sill.\n",
    "    if (...):\n",
    "        Tprev[ix] = Tintrusion\n",
    "    else:\n",
    "        # x[ix] is outside the sill.\n",
    "        # This assumes linear geotherm between\n",
    "        # surface temperature and moho temperature\n",
    "        Tprev[ix] = x[ix] * (Tmoho - Tsurf) / L\n",
    "\n",
    "# Plot initial temperature field\n",
    "plt.plot(Tprev, -x, '.-', label='T initial')\n",
    "plt.legend()\n",
    "plt.show()\n",
    "\n",
    "# Start the loop over time steps\n",
    "curtime = 0\n",
    "while curtime < t_total:\n",
    "    curtime = curtime + dt\n",
    "    \n",
    "    # TODO: Set boundary conditions.\n",
    "    # Set elements zero and `nx-1` of the new temperature field\n",
    "    # to surface temperature and Moho temperature, respectively\n",
    "    (...)\n",
    "    (...)\n",
    "    \n",
    "    # Calculate next values of the internal grid points\n",
    "    for ix in range(1, nx-1):\n",
    "        # TODO: Calculate the new temperature at Tnew[ix] based\n",
    "        # on values in `Tprev`, `k`, `dt`, `rho` and `Cp`.\n",
    "        # Use FD approximation from above and rearrange it\n",
    "        # to get an expression for T_i^{q+1}. Be extra careful\n",
    "        # with correct placement of parentheses!\n",
    "        Tnew[ix] = (...)\n",
    "        \n",
    "    # Copy values from Tnew to Tprev\n",
    "    Tprev[:] = Tnew[:]\n",
    "    \n",
    "\n",
    "# Plot the final temperature field\n",
    "plt.plot(Tnew, -x, '.-', label='T final')\n",
    "plt.legend()\n",
    "plt.show()\n",
    "    \n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
